package service

import (
    "sync"

    log "github.com/Sirupsen/logrus"
    "github.com/pkg/errors"
)


const (
    broadcastChannelSize = 64
)

const (
    stateStopped    = iota
    stateStarted
)

const (
    serviceStopped = iota
    serviceRunning
)

var (
    // Service Running error
    ServiceRunning = &supError{"[ERR] service already running"}
)

type supError struct {
    s string
}

func (n *supError) Error() string {
    return n.s
}

// Event is a special service event that can be generated by various goroutines in the app
type Event struct {
    Name       string
    Payload    interface{}
}

type waiter struct {
    eventName  string
    eventC     chan Event
}

// --- --- --- --- --- --- --- --- --- --- --- --- --- service unit --- --- --- --- --- --- --- --- --- --- --- --- - //

type Service interface {
    // These indicate that the service is named and should be individually managed to start.
    Tag() string

    IsRunning() bool

    // --- internal methods --- //
    setRunning()

    // Serve() allows services to run
    serve() error

    setStopped()

    getWaiters() []*waiter

    // cleanup is only allowed for unnamed services
    cleanup() error
}

// --- --- --- --- --- --- --- --- Service internal structure to coalesce functions --- --- --- --- --- --- --- --- - //

type serveFunc func() error
func (s serveFunc) serve() error {
    return s()
}

type srvcFuncs struct {
    sync.Mutex
    state      int

    tag        string
    waiters    []*waiter
    serveFunc
}

func (s *srvcFuncs) Tag() string {
    return s.tag
}

func (s *srvcFuncs) IsRunning() bool {
    s.Lock()
    defer s.Unlock()

    return (s.state == serviceRunning)
}

func (s *srvcFuncs) setRunning() {
    s.Lock()
    defer s.Unlock()

    s.state = serviceRunning
}

func (s *srvcFuncs) setStopped() {
    s.Lock()
    defer s.Unlock()

    s.state = serviceStopped
}

func (s *srvcFuncs) getWaiters() []*waiter {
    return s.waiters
}

func (s *srvcFuncs) cleanup() error {
    for i := range s.waiters {
        w := s.waiters[i]
        close(w.eventC)
    }
    return nil
}

// --- --- --- --- --- --- --- --- --- --- Service Builder Options and Functions --- --- --- --- --- --- --- --- ---- //

// ServerOption is a functional option passed to the server
type ServiceOption func(app ServiceSupervisor, s Service) error

func BindEventWithService(eventName string, eventC chan Event) ServiceOption {
    return func(app ServiceSupervisor, s Service) error {
        srv, ok := s.(*srvcFuncs)
        if !ok {
            return errors.Errorf("[ERR] invalid service type to bind event")
        }
        if srv == nil {
            return errors.Errorf("[ERR] null service instance to bind event")
        }
        sup, ok := app.(*srvcSupervisor)
        if !ok {
            return errors.Errorf("[ERR] invalid supervisor type to bind event")
        }
        if sup == nil {
            return errors.Errorf("[ERR] null supervisor instance to bind event")
        }
        sup.Lock()
        defer sup.Unlock()

        w := &waiter{
            eventName:  eventName,
            eventC:     eventC,
        }
        srv.waiters = append(srv.waiters, w)
        sup.eventWaiters[eventName] = append(sup.eventWaiters[eventName], w)
        return nil
    }
}

// --- --- --- --- --- --- --- --- --- --- ServiceSupervisor Options and Functions --- --- --- --- --- --- --- --- -- //

type ServiceSupervisor interface {
    BroadcastEvent(event Event)
    RegisterServiceWithFuncs(tag string, sfn serveFunc, options... ServiceOption) error

    IsStopped() bool
    StopChannel() <- chan struct{}

    StartServices() error
    StopServices() error

    // ---    status info   --- //
    ServiceList() []Service

    // --- internal service --- //
    serviceCount() int
}

func NewServiceSupervisor() ServiceSupervisor {
    return &srvcSupervisor{
        state:           stateStopped,
        waitSync:        &sync.WaitGroup{},
        services:        []Service{},

        eventsC:         make(chan Event, broadcastChannelSize),
        eventWaiters:    make(map[string][]*waiter),

        stoppedC:        make(chan struct{}),
    }
}

type srvcSupervisor struct {
    sync.Mutex
    state           int

    waitSync        *sync.WaitGroup
    services        []Service

    eventWaiters    map[string][]*waiter
    eventsC         chan Event
    stoppedC        chan struct{}
}

// --- --- --- --- --- --- --- --- --- --- Event Related Methods --- --- --- --- --- --- --- --- --- --- --- --- ---- //

func (s *srvcSupervisor) getWaiters(eventName string) []*waiter {
    s.Lock()
    defer s.Unlock()

    waiters := s.eventWaiters[eventName]
    out := make([]*waiter, len(waiters))
    for i := range waiters {
        out[i] = waiters[i]
    }
    return out
}

func (s *srvcSupervisor) notifyWaiter(w *waiter, evt Event) {
    select {
        case w.eventC <- evt:
    }
}

func (s *srvcSupervisor) fanOut() {
    defer s.waitSync.Done()

    for {
        select {
            case <-s.stoppedC: {
                log.Debugf("[SUPERVISOR] fanOut should stop")
                return
            }
            case event := <-s.eventsC: {
                waiters := s.getWaiters(event.Name)
                for _, waiter := range waiters {
                    s.notifyWaiter(waiter, event)
                }
            }
        }
    }
}

func (s *srvcSupervisor) BroadcastEvent(event Event) {
    s.Lock()
    defer s.Unlock()

    go func() {
        select {
            // when the supervisor is stopped, no more event will flow
            case <- s.stoppedC:
            // otherwise, things would work as intended
            case s.eventsC <- event:
        }
    }()
}

// --- --- --- --- --- --- --- --- --- --- Service Related Methods --- --- --- --- --- --- --- --- --- --- --- --- -- //

func (s *srvcSupervisor) runService(service Service) {
    var (
        // this func will be called _after_ a service stops running:
        srvcCleanup = func(ss *srvcSupervisor, srv Service) {
            ss.Lock()
            defer ss.Unlock()

            // cleanup events first
            swaiters := srv.getWaiters()
            for o := range swaiters {
                sw := swaiters[o]
                awaiters := ss.eventWaiters[sw.eventName]
                if len(awaiters) != 0 {
                    var nwaiters []*waiter = []*waiter{}
                    for i := range awaiters {
                        aw := awaiters[i]
                        if aw != sw {
                            nwaiters = append(nwaiters, aw)
                        }
                    }
                    ss.eventWaiters[sw.eventName] = nwaiters
                }
                log.Debugf("[SUPERVISOR-SERVICE] ['%s' | %v] waiter [%s] cleaned", srv.Tag(), srv, sw.eventName)
            }

            // cleanup service itself
            for i := range ss.services {
                el := ss.services[i]
                if el == srv {
                    ss.services = append(ss.services[:i], ss.services[i+1:]...)
                    break
                }
            }
            err := srv.cleanup()
            if err != nil {
                log.Debug(errors.WithStack(err))
            }
            log.Debugf("[SUPERVISOR-SERVICE] ['%s' | %v] removed", srv.Tag(), srv)
        }
        // this runs service
        srvcRunner = func(ss *srvcSupervisor, waitSync *sync.WaitGroup, srv Service, cleanup func(as *srvcSupervisor, srv Service)) {

            log.Debugf("[SUPERVISOR-SERVICE] ['%s' | %v] started", srv.Tag(), srv)

            srv.setRunning()
            err := srv.serve()
            if err != nil {
                log.Errorf("%s\n%s", srv.Tag(), err.Error())
            }
            cleanup(ss, srv)
            srv.setStopped()
            waitSync.Done()

            log.Debugf("[SUPERVISOR-SERVICE] ['%s' | %v] exited", srv.Tag(), srv)
        }
    )

    s.waitSync.Add(1)
    go srvcRunner(s, s.waitSync, service, srvcCleanup)
}

func (s *srvcSupervisor) registerService(srv Service) error {
    s.Lock()
    defer s.Unlock()

    s.services = append(s.services, srv)

    log.Debugf("[SUPERVISOR-SERVICE] ['%s' | %v] added", srv.Tag(), srv)

    if s.state == stateStarted {
        s.runService(srv)
    }
    return nil
}

func (s *srvcSupervisor) RegisterServiceWithFuncs(tag string, sfn serveFunc, options... ServiceOption) error {
    srv := &srvcFuncs {
        tag:          tag,
        state:        serviceStopped,
        waiters:      []*waiter{},
        serveFunc:    sfn,
    }

    for _, opt := range options {
        if err := opt(s, srv); err != nil {
            return errors.WithStack(err)
        }
    }

    return s.registerService(srv)
}

func (s *srvcSupervisor) IsStopped() bool {
    s.Lock()
    defer s.Unlock()

    if s.state == stateStopped {
        return true
    } else {
        return false
    }
}

func (s *srvcSupervisor) StopChannel() <- chan struct{} {
    return s.stoppedC
}

func (s *srvcSupervisor) StartServices() error {
    s.Lock()
    defer s.Unlock()

    if s.state == stateStarted {
        return nil
    }
    s.state = stateStarted

    s.waitSync.Add(1)
    go s.fanOut()

    if len(s.services) == 0 {
        log.Debugf("[SUPERVISOR] Start() :: nothing to run")
        return nil
    }

    for _, srv := range s.services {
        s.runService(srv)
    }
    return nil
}

func (s *srvcSupervisor) StopServices() error {
    // this double locking to to prevent ServiceFunc from deadlocked, but enable other variables to be reset
    s.Lock()
    if s.state == stateStopped {
        defer s.Unlock()
        return nil
    }
    s.state = stateStopped
    s.Unlock()

    log.Debugf("[SUPERVISOR] stopping services...")

    // Broadcast stopping and wait for all goroutines to close with event channels intact.
    // While services are stopping, there are many races to grap supervisor lock so give grace period
    close(s.stoppedC)
    s.waitSync.Wait()

    s.Lock()
    defer s.Unlock()

    // we close event channel after stopping all go routines and fanOut function that we can safely close
    close(s.eventsC)

    // reconstruct channels. We're to reconstruct event channel as well to clean off queued events
    s.eventsC     = make(chan Event, broadcastChannelSize)
    s.stoppedC    = make(chan struct{})
    return nil
}

func (s *srvcSupervisor) ServiceList() []Service {
    s.Lock()
    defer s.Unlock()

    var sl []Service = []Service{}
    for i, _ := range s.services {
        srv := s.services[i]
        sl = append(sl, srv)
    }
    return sl
}

// ServiceCount returns the number of registered and actively running services
func (s *srvcSupervisor) serviceCount() int {
    s.Lock()
    defer s.Unlock()

    return len(s.services)
}
