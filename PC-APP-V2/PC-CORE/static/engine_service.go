package main

import (
    "sync"

    log "github.com/Sirupsen/logrus"
    "github.com/pkg/errors"
)

/*** SERVICE SECTION ***/
const (
    stateCreated    = iota
    stateStarted
    stateStopped
)

type serveFunc func() error

func (s serveFunc) Serve() error {
    return s()
}

type stopFunc func() error

func (e stopFunc) Stop() error {
    return e()
}

type Service struct {
    Serve      serveFunc
    Stop       stopFunc
}

// Event is a special service event that can be generated by various goroutines in the app
type Event struct {
    Name       string
    Payload    interface{}
}

type Waiter struct {
    eventC     chan Event
    exitC      chan struct{}
}


type Supervisor interface {
    RegisterService(srv Service)
    WaitForEvent(name string, eventC chan Event, cancelC chan struct{})
    IsStopped() bool
    StopChannel() <- chan struct{}
    StartServices() error
    StopServices() error
}

type srvSupervisor struct {
    state int
    sync.Mutex

    serviceWG       *sync.WaitGroup
    services        []*Service

    eventsC         chan Event
    events          map[string]Event
    eventWaiters    map[string][]*Waiter

    stoppedC        chan struct{}
}

// ServiceCount returns the number of registered and actively running services
func (s *srvSupervisor) serviceCount() int {
    s.Lock()
    defer s.Unlock()
    return len(s.services)
}

func (s *srvSupervisor) getWaiters(name string) []*Waiter {
    s.Lock()
    defer s.Unlock()

    waiters := s.eventWaiters[name]
    out := make([]*Waiter, len(waiters))
    for i := range waiters {
        out[i] = waiters[i]
    }
    return out
}

func (s *srvSupervisor) notifyWaiter(w *Waiter, evt Event) {
    select {
        case w.eventC <- evt:
        case <-w.exitC:
    }
}

func (s *srvSupervisor) fanOut() {
    defer s.serviceWG.Done()

    for {
        select {
            case event := <-s.eventsC:
                waiters := s.getWaiters(event.Name)
                for _, waiter := range waiters {
                    go s.notifyWaiter(waiter, event)
                }
            case <-s.stoppedC:
                return
        }
    }
}

func (s *srvSupervisor) serve(srv *Service) {
    // this func will be called _after_ a service stops running:
    removeService := func() {
        s.Lock()
        defer s.Unlock()
        for i, el := range s.services {
            if el == srv {
                s.services = append(s.services[:i], s.services[i+1:]...)
                break
            }
        }
        log.Debugf("[SUPERVISOR] Service %v is done (%v)", *srv, len(s.services))
    }

    s.serviceWG.Add(1)
    go func() {
        defer s.serviceWG.Done()
        defer removeService()

        log.Debugf("[SUPERVISOR] Service %v started (%v)", *srv, s.serviceCount())
        err := (*srv).Serve()
        if err != nil {
            log.Debug(errors.WithStack(err))
        }
        err = (*srv).Stop()
        if err != nil {
            log.Debug(errors.WithStack(err))
        }
    }()
}

func (s *srvSupervisor) RegisterService(srv Service) {
    s.Lock()
    defer s.Unlock()
    s.services = append(s.services, &srv)

    log.Debugf("[SUPERVISOR] Service %v added (%v)", srv, len(s.services))

    if s.state == stateStarted {
        s.serve(&srv)
    }
}

func (s *srvSupervisor) BroadcastEvent(event Event) {
    s.Lock()
    defer s.Unlock()
    s.events[event.Name] = event
    log.Debugf("[SUPERVISOR] BroadcastEvent: %v", &event)

    go func() {
        s.eventsC <- event
    }()
}

func (s *srvSupervisor) WaitForEvent(name string, eventC chan Event, cancelC chan struct{}) {
    s.Lock()
    defer s.Unlock()

    waiter := &Waiter{eventC: eventC, exitC: cancelC}
    event, ok := s.events[name]
    if ok {
        go s.notifyWaiter(waiter, event)
        return
    }
    s.eventWaiters[name] = append(s.eventWaiters[name], waiter)
}

func (s *srvSupervisor) IsStopped() bool {
    select {
        case <- s.stoppedC:
            return true
        default:
            return false
    }
}

func (s *srvSupervisor) StopChannel() <- chan struct{} {
    return s.stoppedC
}

func (s *srvSupervisor) StartServices() error {
    s.Lock()
    defer s.Unlock()

    if s.state == stateStarted {
        return nil
    }
    s.state = stateStarted

    s.serviceWG.Add(1)
    go s.fanOut()

    if len(s.services) == 0 {
        log.Warning("[SUPERVISOR] Start() :: nothing to run")
        return nil
    }

    for _, srv := range s.services {
        s.serve(srv)
    }

    return nil
}

func (s *srvSupervisor) StopServices() error {
    s.Lock()
    defer s.Unlock()

    if s.state == stateStopped {
        return nil
    }
    s.state = stateStopped

    log.Warning("[SUPERVISOR] stopping services...")
    close(s.stoppedC)
    s.serviceWG.Wait()

    // reset waiters
    log.Warning("[SUPERVISOR] removing waiters...")
    var (
        waiters []*Waiter
        w *Waiter
    )
    for _, waiters = range s.eventWaiters {
        for _, w = range waiters {
            close(w.eventC)
            close(w.exitC)
        }
    }
    s.eventWaiters = make(map[string][]*Waiter)

    // reset events
    log.Warning("[SUPERVISOR] removing events...")
    s.events = map[string]Event{}

    // reset closer as it's not being monitored anymore
    s.stoppedC = make(chan struct{})

    return nil
}

func newServiceSupervisor() *srvSupervisor {
    return &srvSupervisor{
        serviceWG:       &sync.WaitGroup{},
        services:        []*Service{},

        eventsC:         make(chan Event, 100),
        events:          map[string]Event{},
        eventWaiters:    make(map[string][]*Waiter),

        stoppedC:        make(chan struct{}),
    }
}